% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/combine_observations.R
\name{combine_observations}
\alias{combine_observations}
\title{Combine parsed observations into a single parsed object}
\usage{
combine_observations(...)
}
\arguments{
\item{...}{Parsed datasets to combine (i.e., outputs from 
\code{Xcertainty::parsed_observations})}
}
\description{
Combine parsed observations into a single parsed object
}
\examples{
devtools::document()

# load example wide-format data
data("calibration")
data("whales")

# parse calibration study
calibration_data = parse_observations(
  x = calibration, 
  subject_col = 'CO.ID',
  meas_col = 'Lpix', 
  tlen_col = 'CO.L', 
  image_col = 'image', 
  barometer_col = 'Baro_Alt', 
  laser_col = 'Laser_Alt', 
  flen_col = 'Focal_Length', 
  iwidth_col = 'Iw', 
  swidth_col = 'Sw',
  uas_col = 'uas'
)

# parse field study
whale_data = parse_observations(
  x = whales, 
  subject_col = 'whale_ID',
  meas_col = 'TL.pix', 
  image_col = 'Image', 
  barometer_col = 'AltitudeBarometer', 
  laser_col = 'AltitudeLaser', 
  flen_col = 'FocalLength', 
  iwidth_col = 'ImageWidth', 
  swidth_col = 'SensorWidth', 
  uas_col = 'UAS'
)

sampler = build_sampler(
  data = combine_observations(calibration_data, whale_data),
  priors = list(
    altitude = c(min = 0.1, max = 130),
    lengths = c(min = 0, max = 30),
    bias = rbind(
      Barometer = c(mean = 0, sd = 1e2),
      Laser = c(mean = 0, sd = 1e2),
      Pixels = c(mean = 0, sd = 1e2)
    ),
    sigma = rbind(
      Barometer = c(shape = .01, rate = .01),
      Laser = c(shape = .01, rate = .01),
      Pixels = c(shape = .01, rate = .01)
    )
  )
)





# draw posterior samples
niter = 1e4
burn = 1:(niter/2)
standard_sampler$run(niter = niter)
calibration_sampler$run(niter = niter)

niter2 = 1e3
burn2 = 1:(niter2/2)
tick = proc.time()[3]
calibrated_obs_sampler$run(niter = niter2, reset = TRUE)
tock = proc.time()[3]
(tock-tick)/niter2

# clear evidence that the posterior under the joint model is somewhat unstable
nodes = c('sigma[1]','sigma[2]','sigma[3]')
colMeans(as.matrix(standard_sampler$mvSamples)[-burn, nodes])
colMeans(as.matrix(calibration_sampler$mvSamples)[-burn, nodes])


# look at the estimated lengths under the different schemes
calibrated_samples = as.matrix(calibrated_obs_sampler$mvSamples)
calibrated_length_samples = as.matrix(calibrated_obs_sampler$mvSamples2)
standard_length_samples = as.matrix(standard_sampler$mvSamples2)

# saveRDS(c alibrated_length_samples, file = 'calibrated_length_samples.rds')

ind = 300
plot(mcmc(calibrated_length_samples[-burn2,ind]))
plot(mcmc(standard_length_samples[-burn,ind]))

plot(density(standard_length_samples[-burn,ind]), ylim = c(0,32))
lines(density(calibrated_length_samples[-burn2,ind]), col = 2)


sd(mcmc(calibrated_length_samples[-burn2,ind]))
sd(mcmc(standard_length_samples[-burn,ind]))

HPDinterval(mcmc(calibrated_length_samples[-burn2,ind]))
HPDinterval(mcmc(standard_length_samples[-burn,ind]))

effectiveSize(mcmc(calibrated_length_samples[-burn2,ind]))

plot(mcmc(calibrated_samples[-burn2,ind]))

plot(mcmc(calibrated_length_samples[-burn2,ind]))


devtools::document()


# TODO: write a model to allow changes over season per length, so that we 
# may work toward a more robust model for growth, but do some EDA on the 
# individual lengths first to see if there are some relationships to be seen

# TODO: write a model to output estimates of maturity based on TL

L_template = nimble::nimbleCode({
  # pattern for relationship per individual: will be expanded following df
  TL.50.0..Width ~ dnorm(mean = beta[1] + beta[2] * TL, var = sigma_w)
  TL ~ dnorm(mean = mu_tl, var = sigma_tl)
})

L_priors = nimble::nimbleCode({
  # relationship priors
  beta[1] ~ dnorm(mean = 0 , sd = 1e2)
  beta[2] ~ dnorm(mean = 0, sd = 1e2)
  mu_tl ~ dnorm(mean = 0, sd = 1e2)
  sigma_w ~ dinvgamma(shape = .01, rate = .01)
  sigma_tl ~ dinvgamma(shape = .01, rate = .01)
  
})

L_substitutions = data.frame(
  subject = unique(project_pkg$maps$L$Subject)
) \%>\% mutate(
  TL = getMeasurementNode(subject, 'TL', project_pkg),
  TL.50.0..Width = getMeasurementNode(subject, 'TL.50.0..Width', project_pkg)
) \%>\% 
  filter(complete.cases(.))

L_model = expand_template(
  template = L_template, substitutions = L_substitutions
)

# add components for length model to analysis package
project_pkg$inits$beta = c(0,0)
project_pkg$inits$mu_tl = 8
project_pkg$inits$sigma_w = 1
project_pkg$inits$sigma_tl = 1

# build calibrated model
standard_tl50_model = build_model(
  pkg = project_pkg, useBarometer = TRUE, useLaser = TRUE,
  length_model = combine_models(L_model, L_priors)
)

standard_tl50_sampler = build_mcmc(
  model = standard_tl50_model, pkg = project_pkg
)
}
